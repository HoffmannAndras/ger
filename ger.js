// Generated by CoffeeScript 1.7.1
(function() {
  var GER, RET, Utils, bb, knex,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  bb = require('bluebird');

  Utils = {
    flatten: function(arr) {
      return arr.reduce((function(xs, el) {
        if (Array.isArray(el)) {
          return xs.concat(Utils.flatten(el));
        } else {
          return xs.concat([el]);
        }
      }), []);
    }
  };

  GER = (function() {
    function GER(esm) {
      var plural, v, _fn, _i, _len, _ref;
      this.esm = esm;
      this.weighted_probabilities_to_action_things_by_people = __bind(this.weighted_probabilities_to_action_things_by_people, this);
      this.probability_of_person_actioning_thing = __bind(this.probability_of_person_actioning_thing, this);
      this.get_list_to_size = __bind(this.get_list_to_size, this);
      this.INITIAL_PERSON_WEIGHT = 10;
      plural = {
        'person': 'people',
        'thing': 'things'
      };
      _ref = [
        {
          object: 'person',
          subject: 'thing'
        }, {
          object: 'thing',
          subject: 'person'
        }
      ];
      _fn = (function(_this) {
        return function(v) {
          _this["similar_" + plural[v.object] + "_for_action"] = function(object, action) {
            return _this.esm["get_" + plural[v.subject] + "_that_actioned_" + v.object](object, action).then(function(subjects) {
              return _this.esm["get_" + plural[v.object] + "_that_actioned_" + plural[v.subject]](subjects, action);
            }).then(function(objects) {
              return Utils.flatten(objects);
            }).then(function(objects) {
              return objects.filter(function(s_object) {
                return s_object !== object;
              });
            });
          };
          _this["similar_" + plural[v.object] + "_for_action_with_weights"] = function(object, action, weight) {
            return _this["similar_" + plural[v.object] + "_for_action"](object, action).then(function(objects) {
              var o, temp, _j, _len1;
              temp = {};
              for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
                o = objects[_j];
                if (!(o in temp)) {
                  temp[o] = 0;
                }
                temp[o] += weight;
              }
              return temp;
            });
          };
          return _this["weighted_similar_" + plural[v.object]] = function(object) {
            var total_action_weight;
            total_action_weight = 0;
            return this.esm.get_ordered_action_set_with_weights().then((function(_this) {
              return function(action_weights) {
                var fn;
                fn = function(i) {
                  if (i >= action_weights.length) {
                    return bb["try"](function() {
                      return null;
                    });
                  } else {
                    return _this["similar_" + plural[v.object] + "_for_action_with_weights"](object, action_weights[i].key, action_weights[i].weight);
                  }
                };
                return _this.get_list_to_size(fn, 0, [], _this.esm.similar_objects_limit);
              };
            })(this)).then((function(_this) {
              return function(object_weights) {
                var k, ows, p, person, person_weight, pw, ret, temp, total_weight, w, weight, _j, _k, _len1, _len2;
                temp = {};
                total_weight = 0;
                for (_j = 0, _len1 = object_weights.length; _j < _len1; _j++) {
                  ows = object_weights[_j];
                  for (p in ows) {
                    w = ows[p];
                    if (p === void 0 || w === NaN) {
                      continue;
                    }
                    if (!(p in temp)) {
                      temp[p] = 0;
                    }
                    temp[p] += w;
                    total_weight += w;
                  }
                }
                pw = ((function() {
                  var _results;
                  _results = [];
                  for (k in temp) {
                    w = temp[k];
                    _results.push([k, w / total_weight]);
                  }
                  return _results;
                })()).sort(function(a, b) {
                  return b[1] - a[1];
                }).slice(0, _this.esm.similar_objects_limit);
                pw.unshift([object, 1]);
                ret = {
                  map: {},
                  people: [],
                  total_weight: 0,
                  ordered_list: pw
                };
                for (_k = 0, _len2 = pw.length; _k < _len2; _k++) {
                  person_weight = pw[_k];
                  person = person_weight[0];
                  weight = person_weight[1];
                  ret.people.push(person);
                  ret.total_weight += weight;
                  ret.map[person] = weight;
                }
                return ret;
              };
            })(this));
          };
        };
      })(this);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _fn(v);
      }
    }

    GER.prototype.get_list_to_size = function(fn, i, list, size) {
      if (list.length > size) {
        return bb["try"](function() {
          return list;
        });
      }
      return fn(i).then((function(_this) {
        return function(new_list) {
          if (new_list === null) {
            return bb["try"](function() {
              return list;
            });
          }
          new_list = list.concat(new_list);
          i = i + 1;
          return _this.get_list_to_size(fn, i, new_list, size);
        };
      })(this));
    };

    GER.prototype.probability_of_person_actioning_thing = function(object, action, subject) {
      return this.esm.has_person_actioned_thing(object, action, subject).then((function(_this) {
        return function(inc) {
          if (inc) {
            return 1;
          } else {
            return _this.esm.get_actions_of_person_thing_with_weights(object, subject).then(function(action_weights) {
              var as, _i, _len, _results;
              _results = [];
              for (_i = 0, _len = action_weights.length; _i < _len; _i++) {
                as = action_weights[_i];
                _results.push(as.weight);
              }
              return _results;
            }).then(function(action_weights) {
              return action_weights.reduce((function(x, y) {
                return x + y;
              }), 0);
            });
          }
        };
      })(this));
    };

    GER.prototype.weighted_probabilities_to_action_things_by_people = function(things, action, people_weights) {
      return this.esm.events_for_people_action_things(people_weights.people, action, things).then(function(events) {
        var e, things_weight, _i, _len;
        things_weight = {};
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          e = events[_i];
          if (!(e.thing in things_weight)) {
            things_weight[e.thing] = 0;
          }
          things_weight[e.thing] += people_weights.map[e.person] / people_weights.total_weight;
        }
        return things_weight;
      });
    };

    GER.prototype.recommendations_for_thing = function(thing, action) {
      return this.esm.get_people_that_actioned_thing(thing, action).then((function(_this) {
        return function(people) {
          var list_of_promises, p;
          list_of_promises = bb.all((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = people.length; _i < _len; _i++) {
              p = people[_i];
              _results.push(this.weighted_similar_people(p));
            }
            return _results;
          }).call(_this));
          return bb.all([people, list_of_promises]);
        };
      })(this)).spread((function(_this) {
        return function(people, peoples_lists) {
          var person, pl, temp, weight, _i, _len, _ref;
          temp = {};
          for (_i = 0, _len = peoples_lists.length; _i < _len; _i++) {
            pl = peoples_lists[_i];
            _ref = pl.map;
            for (person in _ref) {
              weight = _ref[person];
              if (!(person in temp)) {
                temp[person] = 0;
              }
              temp[person] += weight;
            }
          }
          return temp;
        };
      })(this)).then(function(recommendations) {
        var person, sorted_people, temp, ts, weight, weighted_people, _i, _len, _results;
        weighted_people = (function() {
          var _results;
          _results = [];
          for (person in recommendations) {
            weight = recommendations[person];
            _results.push([person, weight]);
          }
          return _results;
        })();
        sorted_people = weighted_people.sort(function(x, y) {
          return y[1] - x[1];
        });
        _results = [];
        for (_i = 0, _len = sorted_people.length; _i < _len; _i++) {
          ts = sorted_people[_i];
          _results.push(temp = {
            weight: ts[1],
            person: ts[0]
          });
        }
        return _results;
      });
    };

    GER.prototype.recommendations_for_person = function(person, action) {
      return this.weighted_similar_people(person).then((function(_this) {
        return function(people_weights) {
          return bb.all([people_weights, _this.esm.things_people_have_actioned(action, people_weights.people)]);
        };
      })(this)).spread((function(_this) {
        return function(people_weights, things) {
          return _this.weighted_probabilities_to_action_things_by_people(things, action, people_weights);
        };
      })(this)).then(function(recommendations) {
        var ret, sorted_things, temp, thing, ts, weight, weight_things, _i, _len;
        weight_things = (function() {
          var _results;
          _results = [];
          for (thing in recommendations) {
            weight = recommendations[thing];
            _results.push([thing, weight]);
          }
          return _results;
        })();
        sorted_things = weight_things.sort(function(x, y) {
          return y[1] - x[1];
        });
        ret = [];
        for (_i = 0, _len = sorted_things.length; _i < _len; _i++) {
          ts = sorted_things[_i];
          temp = {
            weight: ts[1],
            thing: ts[0]
          };
          ret.push(temp);
        }
        return ret;
      });
    };

    GER.prototype.count_events = function() {
      return this.esm.count_events();
    };

    GER.prototype.event = function(person, action, thing, dates) {
      if (dates == null) {
        dates = {};
      }
      return this.esm.add_event(person, action, thing, dates).then(function() {
        return {
          person: person,
          action: action,
          thing: thing
        };
      });
    };

    GER.prototype.action = function(action, weight, override) {
      if (weight == null) {
        weight = 1;
      }
      if (override == null) {
        override = true;
      }
      return this.esm.set_action_weight(action, weight, override).then(function() {
        return {
          action: action,
          weight: weight
        };
      });
    };

    GER.prototype.find_event = function(person, action, thing) {
      return this.esm.find_event(person, action, thing);
    };

    GER.prototype.get_action = function(action) {
      return this.esm.get_action_weight(action).then(function(weight) {
        if (weight === null) {
          return null;
        }
        return {
          action: action,
          weight: weight
        };
      });
    };

    GER.prototype.bootstrap = function(stream) {
      return this.esm.bootstrap(stream);
    };

    GER.prototype.compact_database = function() {
      return bb.all([this.esm.remove_expired_events(), this.esm.remove_non_unique_events()]);
    };

    GER.prototype.compact_database_to_size = function(number_of_events) {
      return bb.all([this.esm.remove_superseded_events(), this.esm.remove_excessive_user_events()]).then((function(_this) {
        return function() {
          return _this.count_events();
        };
      })(this)).then((function(_this) {
        return function(count) {
          if (count <= number_of_events) {
            return count;
          } else {
            return _this.esm.remove_events_till_size(number_of_events);
          }
        };
      })(this));
    };

    return GER;

  })();

  RET = {};

  RET.GER = GER;

  knex = require('knex');

  RET.knex = knex;

  RET.PsqlESM = require('./lib/psql_esm');

  if (typeof define !== 'undefined' && define.amd) {
    define([], function() {
      return RET;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = RET;
  }

}).call(this);
