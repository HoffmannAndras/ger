// Generated by CoffeeScript 1.7.1
(function() {
  var CounterStream, EventStoreMapper, Transform, bb, copyFrom, drop_tables, fs, get_list_to_size, init_action_table, init_events_table, init_tables, pg, split,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  bb = require('bluebird');

  fs = require('fs');

  split = require('split');

  pg = require('pg');

  copyFrom = require('pg-copy-streams').from;

  get_list_to_size = (function(_this) {
    return function(fn, i, list, size) {
      if (list.length > size) {
        return bb["try"](function() {
          return list;
        });
      }
      return fn(i).then(function(new_list) {
        if (new_list === null) {
          return bb["try"](function() {
            return list;
          });
        }
        new_list = list.concat(new_list);
        i = i + 1;
        return get_list_to_size(fn, i, new_list, size);
      });
    };
  })(this);

  Transform = require('stream').Transform;

  CounterStream = (function(_super) {
    __extends(CounterStream, _super);

    function CounterStream() {
      return CounterStream.__super__.constructor.apply(this, arguments);
    }

    CounterStream.prototype._transform = function(chunk, encoding, done) {
      this.count |= 0;
      if (chunk.toString().trim() !== '') {
        this.count += 1;
      }
      this.push(chunk);
      return done();
    };

    return CounterStream;

  })(Transform);

  init_events_table = function(knex, schema) {
    return knex.schema.createTable("" + schema + ".events", function(table) {
      table.increments();
      table.string('person').index().notNullable();
      table.string('action').index().notNullable();
      table.string('thing').index().notNullable();
      table.timestamp('created_at').notNullable();
      return table.timestamp('expires_at');
    });
  };

  init_action_table = function(knex, schema) {
    return knex.schema.createTable("" + schema + ".actions", function(table) {
      table.increments();
      table.string('action').unique().index().notNullable();
      table.integer('weight').notNullable();
      table.timestamp('created_at').notNullable();
      return table.timestamp('updated_at').notNullable();
    });
  };

  drop_tables = function(knex, schema) {
    if (schema == null) {
      schema = 'public';
    }
    return bb.all([knex.schema.dropTableIfExists("" + schema + ".events"), knex.schema.dropTableIfExists("" + schema + ".actions")]).then(function() {
      return knex.schema.raw("DROP SCHEMA IF EXISTS " + schema);
    });
  };

  init_tables = function(knex, schema) {
    if (schema == null) {
      schema = 'public';
    }
    return knex.schema.raw("CREATE SCHEMA IF NOT EXISTS " + schema).then((function(_this) {
      return function() {
        return bb.all([init_events_table(knex, schema), init_action_table(knex, schema)]);
      };
    })(this));
  };

  EventStoreMapper = (function() {
    function EventStoreMapper(knex, schema, limits) {
      this.knex = knex;
      this.schema = schema != null ? schema : 'public';
      if (limits == null) {
        limits = {};
      }
      this.get_people_that_actioned_thing = __bind(this.get_people_that_actioned_thing, this);
      this.get_things_that_actioned_person = __bind(this.get_things_that_actioned_person, this);
      this.get_people_that_actioned_things = __bind(this.get_people_that_actioned_things, this);
      this.get_things_that_actioned_people = __bind(this.get_things_that_actioned_people, this);
      this.similar_objects_limit = limits.similar_objects_limit || 100;
      this.things_limit = limits.things_limit || 100;
      this.people_limit = limits.people_limit || 100;
      this.upper_limit = limits.upper_limit || 10000;
    }

    EventStoreMapper.prototype.drop_tables = function() {
      return drop_tables(this.knex, this.schema);
    };

    EventStoreMapper.prototype.init_tables = function() {
      return init_tables(this.knex, this.schema);
    };

    EventStoreMapper.prototype.add_event = function(person, action, thing, dates) {
      var created_at, expires_at;
      if (dates == null) {
        dates = {};
      }
      expires_at = dates.expires_at;
      created_at = dates.created_at || new Date().toISOString();
      return this.add_event_to_db(person, action, thing, created_at, expires_at);
    };

    EventStoreMapper.prototype.upsert = function(table, insert_attr, identity_attr, update_attr) {
      var insert, query, update;
      insert = this.knex(table).insert(insert_attr).toString();
      insert = insert.replace(/\svalues\s\(/, " select ").slice(0, -1);
      update = this.knex(table).where(identity_attr).update(update_attr).toString();
      query = "BEGIN; LOCK TABLE " + table + " IN SHARE ROW EXCLUSIVE MODE; WITH upsert AS (" + update + " RETURNING *) " + insert + " WHERE NOT EXISTS (SELECT * FROM upsert); COMMIT;";
      return this.knex.raw(query);
    };

    EventStoreMapper.prototype.find_event = function(person, action, thing) {
      return this.knex("" + this.schema + ".events").select("person", "action", "thing", "created_at", "expires_at").where({
        person: person,
        action: action,
        thing: thing
      }).limit(1).then(function(rows) {
        if (rows.length > 0) {
          return rows[0];
        } else {
          return null;
        }
      });
    };

    EventStoreMapper.prototype.add_event_to_db = function(person, action, thing, created_at, expires_at) {
      var identity_attr, insert_attr, update_attr;
      if (expires_at == null) {
        expires_at = null;
      }
      insert_attr = {
        person: person,
        action: action,
        thing: thing,
        created_at: created_at,
        expires_at: expires_at
      };
      identity_attr = {
        person: person,
        action: action,
        thing: thing
      };
      update_attr = {
        created_at: created_at,
        expires_at: expires_at
      };
      return this.upsert("" + this.schema + ".events", insert_attr, identity_attr, update_attr);
    };

    EventStoreMapper.prototype.set_action_weight = function(action, weight, overwrite) {
      var identity_attr, insert_attr, now, update_attr;
      if (overwrite == null) {
        overwrite = true;
      }
      now = new Date().toISOString();
      insert_attr = {
        action: action,
        weight: weight,
        created_at: now,
        updated_at: now
      };
      identity_attr = {
        action: action
      };
      update_attr = {
        action: action,
        updated_at: now
      };
      if (overwrite) {
        update_attr["weight"] = weight;
      }
      return this.upsert("" + this.schema + ".actions", insert_attr, identity_attr, update_attr);
    };

    EventStoreMapper.prototype.events_for_people_action_things = function(people, action, things) {
      if (people.length === 0 || things.length === 0) {
        return bb["try"](function() {
          return [];
        });
      }
      return this.knex("" + this.schema + ".events").select('person', 'thing').max('created_at').groupBy('person', 'thing').orderByRaw('MAX(created_at) DESC').where({
        action: action
      }).whereIn('person', people).whereIn('thing', things).limit(this.upper_limit);
    };

    EventStoreMapper.prototype.has_person_actioned_thing = function(person, action, thing) {
      return this.has_event(person, action, thing);
    };

    EventStoreMapper.prototype.get_actions_of_person_thing_with_weights = function(person, thing) {
      return this.knex("" + this.schema + ".events").select("" + this.schema + ".events.action as key", "" + this.schema + ".actions.weight").leftJoin("" + this.schema + ".actions", "" + this.schema + ".events.action", "" + this.schema + ".actions.action").where({
        person: person,
        thing: thing
      }).orderBy('weight', 'desc').limit(this.upper_limit);
    };

    EventStoreMapper.prototype.get_ordered_action_set_with_weights = function() {
      return this.knex("" + this.schema + ".actions").select('action as key', 'weight').orderBy('weight', 'desc');
    };

    EventStoreMapper.prototype.get_action_weight = function(action) {
      return this.knex("" + this.schema + ".actions").select('weight').where({
        action: action
      }).then(function(rows) {
        if (rows.length > 0) {
          return parseInt(rows[0].weight);
        } else {
          return null;
        }
      });
    };

    EventStoreMapper.prototype.get_things_that_actioned_people = function(people, action) {
      if (people.length === 0) {
        return bb["try"](function() {
          return [];
        });
      }
      return this.knex("" + this.schema + ".events").select('person', 'thing').max('created_at').groupBy('person', 'thing').orderByRaw('MAX(created_at) DESC').where({
        action: action
      }).whereIn('person', people).limit(this.upper_limit).then(function(rows) {
        var r, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          r = rows[_i];
          _results.push(r.thing);
        }
        return _results;
      });
    };

    EventStoreMapper.prototype.get_people_that_actioned_things = function(things, action) {
      if (things.length === 0) {
        return bb["try"](function() {
          return [];
        });
      }
      return this.knex("" + this.schema + ".events").select('person', 'thing').max('created_at').groupBy('person', 'thing').orderByRaw('MAX(created_at) DESC').where({
        action: action
      }).whereIn('thing', things).limit(this.upper_limit).then(function(rows) {
        var r, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          r = rows[_i];
          _results.push(r.person);
        }
        return _results;
      });
    };

    EventStoreMapper.prototype.get_things_that_actioned_person = function(person, action) {
      return this.knex("" + this.schema + ".events").select('person', 'thing').max('created_at').groupBy('person', 'thing').orderByRaw('MAX(created_at) DESC').where({
        person: person,
        action: action
      }).limit(this.things_limit).then(function(rows) {
        var r, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          r = rows[_i];
          _results.push(r.thing);
        }
        return _results;
      });
    };

    EventStoreMapper.prototype.get_people_that_actioned_thing = function(thing, action) {
      return this.knex("" + this.schema + ".events").select('person', 'thing').max('created_at').groupBy('person', 'thing').orderByRaw('MAX(created_at) DESC').where({
        thing: thing,
        action: action
      }).limit(this.people_limit).then(function(rows) {
        var r, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          r = rows[_i];
          _results.push(r.person);
        }
        return _results;
      });
    };

    EventStoreMapper.prototype.things_people_have_actioned = function(action, people) {
      return this.knex("" + this.schema + ".events").select('thing').max('created_at').groupBy('thing').orderByRaw('MAX(created_at) DESC').where({
        action: action
      }).whereIn('person', people).limit(this.things_limit).then(function(rows) {
        var r, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          r = rows[_i];
          _results.push(r.thing);
        }
        return _results;
      });
    };

    EventStoreMapper.prototype.things_jaccard_metric = function(thing1, thing2, action) {
      var intersection, q1, q2, union;
      q1 = this.knex("" + this.schema + ".events").select('person').distinct().where({
        thing: thing1,
        action: action
      }).toString();
      q2 = this.knex("" + this.schema + ".events").select('person').distinct().where({
        thing: thing2,
        action: action
      }).toString();
      intersection = this.knex.raw("" + q1 + " INTERSECT " + q2);
      union = this.knex.raw("" + q1 + " UNION " + q2);
      return bb.all([intersection, union]).spread(function(int_count, uni_count) {
        var ret;
        ret = int_count.rowCount / uni_count.rowCount;
        if (isNaN(ret)) {
          return 0;
        }
        return ret;
      });
    };

    EventStoreMapper.prototype.people_jaccard_metric = function(person1, person2, action) {
      var intersection, q1, q2, union;
      q1 = this.knex("" + this.schema + ".events").select('thing').distinct().where({
        person: person1,
        action: action
      }).toString();
      q2 = this.knex("" + this.schema + ".events").select('thing').distinct().where({
        person: person2,
        action: action
      }).toString();
      intersection = this.knex.raw("" + q1 + " INTERSECT " + q2);
      union = this.knex.raw("" + q1 + " UNION " + q2);
      return bb.all([intersection, union]).spread(function(int_count, uni_count) {
        var ret;
        ret = int_count.rowCount / uni_count.rowCount;
        if (isNaN(ret)) {
          return 0;
        }
        return ret;
      });
    };

    EventStoreMapper.prototype.has_event = function(person, action, thing) {
      return this.knex("" + this.schema + ".events").where({
        person: person,
        action: action,
        thing: thing
      }).then(function(rows) {
        return rows.length > 0;
      });
    };

    EventStoreMapper.prototype.has_action = function(action) {
      return this.knex("" + this.schema + ".actions").where({
        action: action
      }).then(function(rows) {
        return rows.length > 0;
      });
    };

    EventStoreMapper.prototype.count_events = function() {
      return this.knex("" + this.schema + ".events").count().then(function(count) {
        return parseInt(count[0].count);
      });
    };

    EventStoreMapper.prototype.count_actions = function() {
      return this.knex("" + this.schema + ".actions").count().then(function(count) {
        return parseInt(count[0].count);
      });
    };

    EventStoreMapper.prototype.bootstrap = function(stream) {
      var runner;
      runner = new this.knex.client.Runner(this.knex.client);
      return runner.ensureConnection().then((function(_this) {
        return function(connection) {
          var counter, deferred, pg_stream;
          runner.connection = connection;
          deferred = bb.defer();
          pg_stream = runner.connection.query(copyFrom("COPY " + _this.schema + ".events (person, action, thing, created_at, expires_at) FROM STDIN CSV"));
          counter = new CounterStream();
          stream.pipe(split(/^/gm)).pipe(counter).pipe(pg_stream).on('end', function() {
            return deferred.resolve(counter.count);
          }).on('error', function(error) {
            return deferred.reject(error);
          });
          return deferred.promise;
        };
      })(this))["finally"](function() {
        return runner.cleanupConnection();
      });
    };

    EventStoreMapper.prototype.remove_expired_events = function() {
      var now;
      now = new Date().toISOString();
      return this.knex("" + this.schema + ".events").where('expires_at', '<', now).del();
    };

    EventStoreMapper.prototype.remove_non_unique_events = function() {
      var query;
      query = "DELETE FROM " + this.schema + ".events e1 USING " + this.schema + ".events e2 WHERE e1.person = e2.person AND e1.action = e2.action AND e1.thing = e2.thing AND (e1.created_at < e2.created_at OR (e1.created_at = e2.created_at AND e1.id < e2.id) )";
      return this.knex.raw(query);
    };

    EventStoreMapper.prototype.remove_superseded_events = function() {
      return bb["try"](function() {
        return true;
      });
    };

    EventStoreMapper.prototype.remove_excessive_user_events = function() {
      return bb["try"](function() {
        return true;
      });
    };

    EventStoreMapper.prototype.remove_events_till_size = function(number_of_events) {
      var query;
      query = "delete from " + this.schema + ".events where id not in (select id from " + this.schema + ".events order by created_at desc limit " + number_of_events + ")";
      return this.knex.raw(query);
    };

    return EventStoreMapper;

  })();

  EventStoreMapper.drop_tables = drop_tables;

  EventStoreMapper.init_tables = init_tables;

  if (typeof define !== 'undefined' && define.amd) {
    define([], function() {
      return EventStoreMapper;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = EventStoreMapper;
  }

}).call(this);
